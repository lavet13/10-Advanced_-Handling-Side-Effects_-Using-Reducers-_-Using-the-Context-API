What is an effect, also called a side-effect and I will use these terms interchangeably. So when I say effect
I mean side-effect and the other way around. But what is that? Well, let's not forget that our components in the React app
and our React app as a whole and also especially the React library itself has one main job to render UI to react to our 
user input, to re-render the UI when it's needed. That is what we focused on thus far with state and events and all of that.
The main job was to bring something onto the screen and to make sure that the user may interact with that something
and that what's shown on the screen may change based on certain events. For example, based on a button click or some text
being entered. So therefore that's the main job of React and of our application. We wanna evaluate and render the JSX code
in the DOM. We wanna manage state and props to make sure that every component has the data it needs and that we reflect
the user input correctly. We wanna React to user events as mentioned and of course React is there to also re-evaluate our
components and their JSX code and manipulate the real DOM as needed. So that's all baked into React with the tools and 
features we learned this far. So something like useState hook, props and so on. Component is just a function therefore it's 
execution top to bottom and everything in that function in the end deals with bringing something onto the screen and 
with reacting to user input to clicks and so on. So that's what function is all about. We may use useState in there, we
may have other functions in there, which for example are triggered upon a button press and so on. But everything we have
in this component function is concerned with bringing something onto the screen.

Now, therefore side-effects are everything else that might be happening in your application. And a good example here is 
sending a HTTP-request or storing something in browser storage in local storage for example. But you could also think
about timers or intervals. These tasks are all not related to bringing something onto the screen. At least not directly.
Of course you might be sending a HTTP-request to then draw something onto the screen once you got the response, but sending
the request itself and handling potential errors and so on, that's not something you need React for, that's not something
React cares about, that's not what React is. Therefore it's not something that is related to drawing something onto the screen
directly or anything like that. So these are therefore tasks which must happen outside of the normal component evaluation.
So outside of your normal component function. Because you must not forget that this function, this App function for example
is re-executed by React automatically whenever for example state changes. Whenever isLoggedIn state would change, this entire 
function re-runs and React then basically checks what the new result of this function execution. So the new JSX code looks like
and if compared to the previous result it should go to the real DOM and make some changes there.

Now, if we would send a HTTP-request for example, directly in the component function, then we would send this request
whenever this function re-runs. So for example, whenever this state changes and that might sometimes be what you want
but definitely not always. And if in response to your HTTP-request you for example eventually change some state, you would
even create an infinite loop. Because you would send the request whenever the function re-runs. And in response to your request
you change some state which triggers this function again. So therefore such side effects should not go directly into component
function because that would most likely create bugs, infinite loops or simply send too many HTTP-requests to stick with that
example.

Therefore we'll have a better tool for handling side effects and that's a special React Hook which we can use.
The useEffect hook. The useEffect hook is simply another built in hook. So another function you can run inside of your
component function that will do something special. The useEffect hook is called with two arguments, with two parameters

useEffect(() => { ... }, [dependencies]);

The first argument is a function that should be executed AFTER every component evaluation IF the specified dependencies changed.
And the specified dependencies are the second argument that you pass in. That's an array full of dependencies and whenever
such a dependency changes that first function will re-run. And therefore in that first function you can put any side effect
code and that code will then only execute when the dependencies specified by you changed and not when the component re-renders.
So only when your dependencies changed.

# Introducing useReducer() for State Management
useReducer is another built-in hook and it will help us with state management. So it's a bit like useState, but actually with
more capabilities and especially useful for more complex state. Sometimes you have more complex state, for example 
multiple states that kind of belong together, that are managing the same thing just different aspects of it.
Or you have multiple states that kind of change together or are related. 
In such cases, useState and the state you get from there often becomes hard or error-prone to use and manage.
And it's easy then to write bad or inefficient or potentially buggy code, which is of course it's never what we want.
useReducer() can be used as a replacement for useState() if you need "more powerful state management". Now this does not
mean that you should always use useReducer because it's more powerful, so it's always better. No, because it's also a bit 
more complex to use, it requires a bit more setup. So for a lot of scenarios for the majority I would argue you probably use
useState. But there are cases where the extra work of getting useReducer to work, is just worth it.

# Using the useReducer() hook
const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);
useReducer just like useState always returns an array with exactly two values. And therefore you can use array destructuring
as we did it with useState to pull out these values and store them in separate constants.
First value: latest state snapshot, because it's a state management mechanism like useState.
Second value: function that allows you to update that state snapshot.

So that's kind of the same as for useState, though the state updating function will work differently.
Instead of just setting a new state value, you will dispatch an action. And that action will be consumed by the first
argument you pass to useReducer a so-called reducer function(reducerFn).

# reducerFn
So reducer function gets the latest state snapshop automatically because this function will be called by React
AND it gets the action that was dispatched. Because React will call this reducer function whenever a new action is dispatched
(via dispatchFn). 
Now, the reducer function then also should do one important thing. It should return a new updated state. So it's a bit like
the function form of the useState hook, but an extended version of that, you could say, because of that action thing, which
you'll see in action, no pun intended, in a second.

In addition, you can also set some initial state(initialState) and also an initial function(initFn) that should run to set
the initial state in case your initial state is a bit more complex. And, for example, the result of let's say HTTP requests
or anything like that. We'll ignore that for now. So that's useReducer in theory.

useReducer - это React-хук, который предоставляет более мощный способ управления состоянием в компонентах, чем useState. Он предоставляет способ управления состоянием, основанный на действиях (actions) вместо прямого изменения состояния.

Синтаксис useReducer выглядит следующим образом:

javascript
Copy code
const [state, dispatch] = useReducer(reducer, initialState);
где state - текущее состояние, dispatch - функция, которая позволяет отправлять действия (actions) для изменения состояния, reducer - функция, которая принимает текущее состояние и действие, и возвращает новое состояние, а initialState - начальное состояние.

reducer должен быть чистой функцией, которая не изменяет свой входной аргумент и возвращает новое состояние в зависимости от типа действия. Действия (actions) - это объекты, которые содержат тип и (необязательно) данные для обновления состояния. Пример действия:

javascript
Copy code
{ type: 'INCREMENT', payload: 1 }
где type - строка, определяющая тип действия, и payload - данные, связанные с действием.

Пример использования useReducer:

javascript
Copy code
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + action.payload };
    case 'DECREMENT':
      return { count: state.count - action.payload };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT', payload: 1 })}>Increment</button>
      <button onClick={() => dispatch({ type: 'DECREMENT', payload: 1 })}>Decrement</button>
    </div>
  );
}
Этот компонент Counter использует useReducer для управления состоянием счетчика. Он передает начальное состояние и функцию редуктора reducer в useReducer, а затем использует dispatch для отправки действий для изменения состояния.

useReducer может использоваться для управления более сложными состояниями и обработки нескольких типов действий. Например, он может использоваться для управления формой, где действия могут быть отправкой данных, изменением поля ввода и т.д.